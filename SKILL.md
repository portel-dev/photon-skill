---
name: photon-skill
description: Generate production-ready Photon MCP files (.photon.ts) from natural language descriptions. Use this skill when users want to create MCP servers, AI tools, or automation utilities. Photon is a single-file TypeScript MCP framework - one class file becomes a complete MCP server.
license: MIT
metadata:
  author: Portel
  version: 1.0.0
  category: code-generation
  tags: [mcp, photon, typescript, ai-tools, automation]
---

# Photon MCP Generator Skill

Generate complete, production-ready `.photon.ts` files for creating MCP servers in seconds.

## What is Photon?

Photon is a **convention-based, single-file TypeScript MCP framework**. One `.photon.ts` file = one complete MCP server.

**Key Principles:**
- **One file, one MCP** - No boilerplate, no config files
- **Convention over configuration** - Public async methods automatically become MCP tools
- **Framework-agnostic** - Pure TypeScript classes that work anywhere
- **AI-native** - Designed to be generated by AI in seconds

## When to Use This Skill

Use this skill when users ask to:
- "Create an MCP for..."
- "Build a tool that..."
- "I need automation for..."
- "Generate a Photon MCP for..."
- "Help me organize/manage/track..."

## Core Pattern

```typescript
/**
 * [Name] - [One-line description]
 *
 * [Detailed description of what this does]
 *
 * Common use cases:
 * - [Use case 1]
 * - [Use case 2]
 * - [Use case 3]
 *
 * Configuration:
 * - [param1]: [Description] (default: [value])
 * - [param2]: [Description] (default: [value])
 *
 * Dependencies: [list or "None"]
 *
 * @version 1.0.0
 * @author [Author]
 * @license MIT
 */

import { ... } from '...';

export default class [ClassName] {
  constructor(
    private [param1]: [type] = [default],
    private [param2]: [type] = [default]
  ) {
    // Simple validation only - throw standard Error
    if ([validation]) {
      throw new Error('[Clear error message]');
    }
  }

  async onInitialize() {
    console.error(`[${name}] ✅ Initialized`);
    console.error(`[${name}] Config: ...`);
  }

  /**
   * [Tool description]
   * @param [param] [Description]
   */
  async [toolName](params: { [param]: [type] }) {
    try {
      // Implementation
      return { success: true, [result]: value };
    } catch (error: any) {
      return { success: false, error: error.message };
    }
  }

  // Private helper methods
  private _[helperName]() {
    // Helpers start with _ to exclude from tools
  }
}
```

## Constructor Configuration Rules

### Smart Defaults Strategy

**Use `join(homedir(), ...)` for user directories:**
```typescript
import { homedir } from 'os';

constructor(
  private workdir: string = join(homedir(), 'Documents'),
  private cacheDir: string = join(homedir(), '.cache', 'app-name')
)
```

**Common default patterns:**
- **Directories**: `join(homedir(), 'Documents')`, `join(homedir(), 'Downloads')`
- **API Endpoints**: `'https://api.service.com'`
- **Timeouts**: `30000` (30 seconds)
- **Limits**: `100`, `1000`, `10485760` (10MB)
- **Booleans**: `false` for features, `true` for safety

### Required vs Optional Parameters

**Required (no default):**
```typescript
constructor(
  private apiKey: string,  // ❌ No default - MUST be provided
  private workdir: string  // ❌ No default - MUST be provided
)
```

**Optional (has default):**
```typescript
constructor(
  private timeout: number = 30000,        // ✅ Has default
  private retryCount?: number,            // ✅ Optional with ?
  private cacheDir: string = '/tmp/cache' // ✅ Has default
)
```

## Tool Method Guidelines

### Naming Conventions
- Use **clear, action-oriented names**: `list`, `create`, `delete`, `search`, `fetch`
- Avoid abbreviations: `create` not `crt`, `delete` not `del`
- Use consistent verbs across similar MCPs

### Parameter Design
```typescript
async toolName(params: {
  // Required params first
  requiredParam: string;

  // Optional params with ? suffix
  optionalParam?: string;

  // Complex types
  filters?: {
    status: 'active' | 'inactive';
    tags: string[];
  };
})
```

### Return Format

**Success with data:**
```typescript
return { success: true, data: result, count: items.length };
```

**Success with message:**
```typescript
return { success: true, message: 'Operation completed' };
```

**Error:**
```typescript
return { success: false, error: error.message };
```

**Throw for critical failures:**
```typescript
throw new Error('Critical failure - cannot continue');
```

## Common Patterns

### File System Operations
```typescript
import { readFile, writeFile, readdir } from 'fs/promises';
import { join, resolve, relative } from 'path';
import { existsSync } from 'fs';
import { homedir } from 'os';

export default class Filesystem {
  constructor(
    private workdir: string = join(homedir(), 'Documents')
  ) {
    if (!existsSync(workdir)) {
      throw new Error(`Directory does not exist: ${workdir}`);
    }
  }

  async read(params: { path: string }) {
    const fullPath = resolve(this.workdir, params.path);
    // Security: check path is within workdir
    const rel = relative(this.workdir, fullPath);
    if (rel.startsWith('..')) {
      throw new Error('Access denied: path outside working directory');
    }

    const content = await readFile(fullPath, 'utf-8');
    return { success: true, content };
  }
}
```

### HTTP/API Calls
```typescript
export default class GitHub {
  constructor(
    private token: string,
    private baseUrl: string = 'https://api.github.com'
  ) {
    if (!token) {
      throw new Error('GitHub token is required');
    }
  }

  async listIssues(params: { owner: string; repo: string }) {
    const response = await fetch(
      `${this.baseUrl}/repos/${params.owner}/${params.repo}/issues`,
      {
        headers: {
          'Authorization': `Bearer ${this.token}`,
          'Accept': 'application/vnd.github.v3+json'
        }
      }
    );

    if (!response.ok) {
      return {
        success: false,
        error: `HTTP ${response.status}: ${response.statusText}`
      };
    }

    const issues = await response.json();
    return { success: true, issues, count: issues.length };
  }
}
```

### Database Operations
```typescript
import Database from 'better-sqlite3';

export default class SQLite {
  private db: Database.Database | null = null;

  constructor(
    private dbPath: string = join(homedir(), 'data.db')
  ) {}

  async onInitialize() {
    this.db = new Database(this.dbPath);
    console.error(`[sqlite] Connected to ${this.dbPath}`);
  }

  async query(params: { sql: string; params?: any[] }) {
    if (!this.db) {
      throw new Error('Database not initialized');
    }

    const stmt = this.db.prepare(params.sql);
    const rows = stmt.all(...(params.params || []));
    return { success: true, rows, count: rows.length };
  }

  async onShutdown() {
    if (this.db) {
      this.db.close();
    }
  }
}
```

### Shell Commands
```typescript
import { exec } from 'child_process';
import { promisify } from 'util';

const execAsync = promisify(exec);

export default class Git {
  constructor(
    private cwd: string = process.cwd()
  ) {}

  async status(params: {}) {
    const { stdout, stderr } = await execAsync('git status', { cwd: this.cwd });
    return { success: true, output: stdout || stderr };
  }
}
```

## Dependencies

### Built-in (No Installation)
```typescript
// File System
import { readFile, writeFile, readdir, mkdir, rm } from 'fs/promises';
import { existsSync } from 'fs';

// Path
import { join, resolve, relative, basename } from 'path';

// OS
import { homedir, platform, tmpdir } from 'os';

// Child Process
import { exec, spawn } from 'child_process';
import { promisify } from 'util';

// HTTP
// Use global fetch (Node 18+)
```

### External (Specify in Comments)
```typescript
/**
 * Dependencies: npm install better-sqlite3
 */
import Database from 'better-sqlite3';

/**
 * Dependencies: npm install @octokit/rest
 */
import { Octokit } from '@octokit/rest';
```

## Security Best Practices

### Path Validation
```typescript
private _validatePath(path: string): string {
  const fullPath = resolve(this.workdir, path);
  const rel = relative(this.workdir, fullPath);

  if (rel.startsWith('..')) {
    throw new Error('Access denied: path outside working directory');
  }

  return fullPath;
}
```

### Input Sanitization
```typescript
async execute(params: { command: string }) {
  // Validate against whitelist
  const allowedCommands = ['ls', 'cat', 'grep'];
  const cmd = params.command.split(' ')[0];

  if (!allowedCommands.includes(cmd)) {
    return { success: false, error: 'Command not allowed' };
  }

  // Sanitize input
  const sanitized = params.command.replace(/[;&|`$]/g, '');
  // Execute...
}
```

### API Key Validation
```typescript
constructor(private apiKey: string) {
  if (!apiKey || apiKey.trim() === '') {
    throw new Error('API key is required');
  }

  if (apiKey.length < 20) {
    throw new Error('Invalid API key format');
  }
}
```

## Example Generation Flow

When user requests: **"Create an MCP to manage my GitHub issues"**

### Step 1: Clarify (if needed)
Ask ONE clarifying question only if truly necessary:
- "Should this include PR management or just issues?"
- "Do you want read-only or write access?"

### Step 2: Generate Complete File

```typescript
/**
 * GitHub Issues - Manage GitHub repository issues
 *
 * Provides tools to list, create, update, and close GitHub issues.
 * Supports filtering by labels, assignees, and status.
 *
 * Common use cases:
 * - Daily issue triage and summarization
 * - Automated issue creation from templates
 * - Bulk issue management and labeling
 *
 * Configuration:
 * - token: GitHub personal access token (required)
 * - defaultRepo: Default repository in owner/repo format (optional)
 * - baseUrl: GitHub API URL (default: https://api.github.com)
 *
 * Dependencies: None (uses built-in fetch)
 *
 * @version 1.0.0
 * @author Portel
 * @license MIT
 */

export default class GitHubIssues {
  constructor(
    private token: string,
    private defaultRepo?: string,
    private baseUrl: string = 'https://api.github.com'
  ) {
    if (!token) {
      throw new Error('GitHub token is required');
    }
  }

  async onInitialize() {
    console.error('[github-issues] ✅ Initialized');
    console.error(`[github-issues] Base URL: ${this.baseUrl}`);
    if (this.defaultRepo) {
      console.error(`[github-issues] Default repo: ${this.defaultRepo}`);
    }
  }

  /**
   * List issues in a repository
   * @param repo Repository in owner/repo format (uses default if not specified)
   * @param state Issue state filter: open, closed, or all (default: open)
   * @param labels Comma-separated list of labels to filter by
   */
  async list(params: {
    repo?: string;
    state?: 'open' | 'closed' | 'all';
    labels?: string;
  }) {
    const repo = params.repo || this.defaultRepo;
    if (!repo) {
      return { success: false, error: 'Repository is required' };
    }

    const url = new URL(`${this.baseUrl}/repos/${repo}/issues`);
    if (params.state) url.searchParams.set('state', params.state);
    if (params.labels) url.searchParams.set('labels', params.labels);

    const response = await fetch(url.toString(), {
      headers: this._getHeaders()
    });

    if (!response.ok) {
      return {
        success: false,
        error: `HTTP ${response.status}: ${response.statusText}`
      };
    }

    const issues = await response.json();
    return {
      success: true,
      issues: issues.map(this._formatIssue),
      count: issues.length
    };
  }

  /**
   * Create a new issue
   * @param repo Repository in owner/repo format (uses default if not specified)
   * @param title Issue title
   * @param body Issue description (optional)
   * @param labels Array of label names (optional)
   */
  async create(params: {
    repo?: string;
    title: string;
    body?: string;
    labels?: string[];
  }) {
    const repo = params.repo || this.defaultRepo;
    if (!repo) {
      return { success: false, error: 'Repository is required' };
    }

    const response = await fetch(
      `${this.baseUrl}/repos/${repo}/issues`,
      {
        method: 'POST',
        headers: this._getHeaders(),
        body: JSON.stringify({
          title: params.title,
          body: params.body || '',
          labels: params.labels || []
        })
      }
    );

    if (!response.ok) {
      return {
        success: false,
        error: `HTTP ${response.status}: ${response.statusText}`
      };
    }

    const issue = await response.json();
    return {
      success: true,
      issue: this._formatIssue(issue),
      message: `Created issue #${issue.number}`
    };
  }

  /**
   * Close an issue
   * @param repo Repository in owner/repo format (uses default if not specified)
   * @param issueNumber Issue number to close
   * @param comment Optional comment to add when closing
   */
  async close(params: {
    repo?: string;
    issueNumber: number;
    comment?: string;
  }) {
    const repo = params.repo || this.defaultRepo;
    if (!repo) {
      return { success: false, error: 'Repository is required' };
    }

    // Add comment if provided
    if (params.comment) {
      await fetch(
        `${this.baseUrl}/repos/${repo}/issues/${params.issueNumber}/comments`,
        {
          method: 'POST',
          headers: this._getHeaders(),
          body: JSON.stringify({ body: params.comment })
        }
      );
    }

    // Close the issue
    const response = await fetch(
      `${this.baseUrl}/repos/${repo}/issues/${params.issueNumber}`,
      {
        method: 'PATCH',
        headers: this._getHeaders(),
        body: JSON.stringify({ state: 'closed' })
      }
    );

    if (!response.ok) {
      return {
        success: false,
        error: `HTTP ${response.status}: ${response.statusText}`
      };
    }

    return {
      success: true,
      message: `Closed issue #${params.issueNumber}`
    };
  }

  // Private helper methods
  private _getHeaders() {
    return {
      'Authorization': `Bearer ${this.token}`,
      'Accept': 'application/vnd.github.v3+json',
      'Content-Type': 'application/json'
    };
  }

  private _formatIssue(issue: any) {
    return {
      number: issue.number,
      title: issue.title,
      state: issue.state,
      author: issue.user.login,
      labels: issue.labels.map((l: any) => l.name),
      created: issue.created_at,
      updated: issue.updated_at,
      url: issue.html_url
    };
  }
}
```

### Step 3: Provide Usage Instructions

```bash
# Save the file
cat > ~/.photon/github-issues.photon.ts
# (paste the code above)

# Test it in dev mode
npx photon github-issues --dev

# Generate config for Claude Desktop
npx photon github-issues --config

# Example: Add to Claude Desktop config
{
  "mcpServers": {
    "github-issues": {
      "command": "npx",
      "args": ["@portel/photon", "github-issues"],
      "env": {
        "GITHUB_ISSUES_TOKEN": "ghp_your_token_here",
        "GITHUB_ISSUES_DEFAULT_REPO": "owner/repo"
      }
    }
  }
}
```

## Common MCP Ideas

### Productivity
- **notion-tasks** - Manage Notion tasks and databases
- **calendar-sync** - Sync events across calendars
- **email-digest** - Daily email summaries
- **bookmark-organizer** - Manage browser bookmarks

### Development
- **github-pr** - Pull request management
- **docker-manager** - Container operations
- **log-analyzer** - Parse and analyze logs
- **dep-checker** - Check dependency updates

### Content
- **blog-publisher** - Publish to multiple platforms
- **image-optimizer** - Bulk image processing
- **pdf-tools** - PDF manipulation
- **markdown-converter** - Convert formats

### Automation
- **file-organizer** - Smart file organization
- **backup-manager** - Automated backups
- **screenshot-annotator** - Screenshot management
- **clipboard-history** - Clipboard manager

## Quality Checklist

Before delivering a .photon.ts file, verify:

- [ ] **Complete header comment** with description, use cases, config, dependencies
- [ ] **Constructor validation** throws clear errors
- [ ] **All tools documented** with JSDoc (description + @param tags)
- [ ] **Type-safe parameters** using TypeScript types
- [ ] **Consistent return format** ({ success, ... })
- [ ] **Error handling** in try-catch blocks
- [ ] **Private helpers** start with underscore
- [ ] **Security checks** for file paths, commands, etc.
- [ ] **No Photon-specific code** (framework-agnostic)
- [ ] **Smart defaults** in constructor

## Anti-Patterns to Avoid

❌ **Don't use Photon-specific properties:**
```typescript
private _photonConfigError: string;  // ❌ Framework-specific
```

❌ **Don't add runtime-specific error messages:**
```typescript
throw new Error("MCP configuration error...");  // ❌ Runtime-specific
```

❌ **Don't hardcode paths:**
```typescript
private workdir = '/Users/username/Documents';  // ❌ Hardcoded
```

✅ **Do use portable defaults:**
```typescript
private workdir = join(homedir(), 'Documents');  // ✅ Portable
```

❌ **Don't expose dangerous operations without validation:**
```typescript
async execute(params: { command: string }) {
  await exec(params.command);  // ❌ Dangerous
}
```

✅ **Do validate and sanitize:**
```typescript
async execute(params: { command: string }) {
  const allowed = ['ls', 'cat'];
  if (!allowed.includes(params.command)) {
    return { success: false, error: 'Command not allowed' };
  }
  // Execute...
}
```

## Additional Resources

- **Photon Documentation**: Emphasize convention over configuration
- **TypeScript Best Practices**: Strong typing, clear naming
- **Security**: Input validation, path checking, sanitization
- **Error Handling**: Try-catch, clear messages, graceful degradation

## Output Format

When generating a Photon MCP:

1. **Generate complete .photon.ts file** (copy-pasteable)
2. **Provide save command**: `cat > ~/.photon/[name].photon.ts`
3. **Show test command**: `npx photon [name] --dev`
4. **Show config generation**: `npx photon [name] --config`
5. **Include example environment variables** if needed

Make it **instant** - from idea to working MCP in one response.
